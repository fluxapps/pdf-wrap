{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn PDF Wrap Here you'll find all the documentation and guides to PDF Wrap. Install PDF Wrap npm i pdf-wrap Guides Guides are the perfect match if you're just wanting to create a PDF viewer. Try one of the guides > API Looking for the API of PDF Wrap?. Here you'll find access to the typedoc APIs. Read the API Documentation > Reference Documentation Looking for in-depth knowledge of PDF Wrap? Here you'll find access to the reference documentation. Read the Reference Documentation Examples Looking for finished examples? Here you'll find access to examples made with PDF Wrap. Check out examples >","title":"Home"},{"location":"#learn-pdf-wrap","text":"Here you'll find all the documentation and guides to PDF Wrap. Install PDF Wrap npm i pdf-wrap","title":"Learn PDF Wrap"},{"location":"#guides","text":"Guides are the perfect match if you're just wanting to create a PDF viewer. Try one of the guides >","title":"Guides"},{"location":"#api","text":"Looking for the API of PDF Wrap?. Here you'll find access to the typedoc APIs. Read the API Documentation >","title":"API"},{"location":"#reference-documentation","text":"Looking for in-depth knowledge of PDF Wrap? Here you'll find access to the reference documentation. Read the Reference Documentation","title":"Reference Documentation"},{"location":"#examples","text":"Looking for finished examples? Here you'll find access to examples made with PDF Wrap. Check out examples >","title":"Examples"},{"location":"development-guide/","text":"Development Guide Authors Nicolas M\u00e4rchy Nicolas Sch\u00e4fli Version 1.0.0 Copyright \u00a9 2018 studer + raimann ag, Creative Commons Attribution-ShareAlike 4.0 International License . Prerequisites Yarn - https://yarnpkg.com/lang/en Node.js - https://nodejs.org/en/ MkDocs - https://www.mkdocs.org/ ghp-import - https://github.com/davisp/ghp-import You need ghp-import on your PATH, otherwise you won't be able to publish the documentation. Architecture The API exposed to the user defines mainly interfaces a user can use. In contrast to the paint , which implements the possibility to draw, is only used internal of PDF Wrap. The pdfjs is the PDF.js implementation for the API. Displaying PDF Pages The PDF pages are displayed by PDF.js. But the highlight as well as the drawing are displayed by PDF Wrap. Every page is displayed in a specific way. HIGHLIGHT LAYER This layer contains any text highlighting with a 100% opacity. It is beneath the actual rendered PDF page, so it won't cover the text. PDF LAYER Is the actual PDF page rendered as svg by PDF.js. HIGHLIGHT LAYER TRANSPARENCY This layer contains any highlighting with an opacity of (about 40%). DRAW LAYER The layer contains all drawings made by a user. TEXT LAYER Is the invisible actual text of the PDF page. Is rendered by PDF.js and enables the text selection, because on the PDF LAYER is no text selection available. Must be invisible, because its only purpose is the text selection. The text itself may not have the correct font or exact position on the page. Directory Structure 1. /pdf-wrap - Root The PDF Wrap root directory Every single file and directory of PDF Wrap Directly in this directory are configuration files like package.json or tsconfg.json 2. /build - Build Output Contains all generated output files The /build directory has a specific structure itself. Read more about build directory 3. /docs - Documentation Source Contains the documentation's source files 4. /examples - PDF Wrap Examples Contains examples of how to use PDF Wrap Contains a Dev Viewer example mainly used for development 5. /src - Source Code Contains the source code of PDF Wrap This also contains type definition files of libraries which don't have type definitions them-self 6. /test - Unit Test Contains unit test files This also contains files with Mock object of for example interfaces Unit Test files must end with .spec.ts Mock files must end with .mock.ts Only files ending to .spec.ts or .mock.ts are picked up by Typescript build directory The build directory is the output directory for any file generated through the Tasks . It is structured in a specific way. 1. /javascript - Transpiled Code Directly transpiled typescript code from src and test directory No uglifying No dependencies 2. /libs - Production Ready This code is production ready Uglified With dependencies and additional resources like CSS files 3. /distributions - Distribution Ready This code is ready to be distributed Uglified With dependencies and additional resources like CSS files With README file With CHANGELOG file With modified package.json file 4. /docs - Built Documentation Generated documentation like MkDocs or Typedoc Tasks PDF Wrap uses Gulp for its task management. The gulpfile.js uses the app.properties.js file to get specific directories. The app.properties.js file just exports an object, which resolves important directory paths absolute. build Tasks The build tasks contain tasks all around building the project. clean Cleans the build by removing the build directory. build Transpiles and lints typescript and runs the tests. package Packs the project ready to use. Copies resources needed and uglifies the javascript code. repackage Same as package but executes clean before uglifyJS Uglifies the javascript code docs Tasks The docs tasks contain tasks about generating or publishing the documentation. mkdocs Generates the MkDocs documentation and includes the typedoc. typedoc Generates the typedoc api documentation. publishDoc Generates and publishes the MkDocs. other Tasks The other tasks contain tasks which have more a general purpose, rather than something specific. copyDependencies Copies the projects dependencies. copyImages Copies the images used by PDF.js copyCMaps Copies the cMaps of PDF.js copyPDFJS Copies the PDF.js files needed. copyCSS Copies and concat the CSS files needed. transformPackageJSON Declares every dependency used in package.json as bundledDependencies . This is needed, because PDF Wrap does not come with a bundled js file. Therefore npm needs to know, that the dependencies are bundled. In addition, devDependecies are cleared, because they are not needed for production. transpileTypescript Transpiles typescript to javascript and generates inline source maps. npm Tasks The npm tasks contain tasks used for npmjs . pack Runs yarn pack for the build/distributions/npm directory. publish Publishes the project to npm. verification Tasks The verification tasks contain tasks about testing. test Runts the unit tests. lint Lints the typescript code. Logging PDF Wrap uses typescript-logging . The configuration is abstracted to the user, to enable a unified log output. The logger name The logger name has a specific scheme in order to enable a unified and an exact as possible log output. <namespace>/<file-path>:<class-name> <namespace> The namespace is always the same value: ch/studerraimann/pdfwrap <file-path> The path of the file where you create the logger. The file name must be without the extension and the file path is relative to the src directory of PDF Wrap. <class-name> The class or function name where you create the logger. Example: Class Assuming the class is declared in the file src/services/my-service.ts . export class MyService { private readonly log: Logger = LoggerFactory.getLogger(\"ch/studerraimann/pdfwrap/services/my-service:MyService\"); constructor() { this.log.info(() => \"Call constructor of MyService\"); } Example: File Assuming the function is declared in the file src/services/my-service.ts . export function doSomething() { const log: Logger = LoggerFactory.getLogger(\"ch/studerraimann/pdfwrap/services/my-service:doSomething\"); log.info(() => \"Call doSomething\"); } You should always use the lambda expression for a log message, because this way it will only be executed when its needed. Please note, that the Logger type must be imported from typescript-logging , but the LoggerFactory class is from src/log-config.ts . Why using it this way? PDF Wrap provides an API to configure the logging output way down to a function or class. This way, the logger names are unified and as a result the configuration can be applied to every logger. Read the Reference Documentation about logging to understand the concept better. MkDocs The PDF Wrap documentation is built with MkDocs . The documentation contains the following parts. Home The index of the documentation. Contains a quick start and link to other parts of the documentation. Guides Contains guides with a specific example of a specific part of PDF Wrap. For example: How to implement a Storage Adapter API Documentation The API documentation of PDF Wrap is part of the final output, but is not actually made by MkDocs. Reference Documentation Contains the full in-depth documentation about how to use PDF Wrap. Development Guide Contains guides about the source code and how to develop with PDF Wrap. How to publish the documentation In order to publish the documentation, you must have MkDocs installed and ghp-import must be on your PATH. Then simply run yarn gulp publishDoc This will generate the documentation, updates the gh-pages branch and pushes it to Github. NPM PDF Wrap is published to npm.js . How to publish PDF Wrap In order to publish this project to npm you have to log in with your npm account yarn login Then simply run yarn gulp publish It is important to use this command and NOT yarn publish directly, because the gulp command will prepare PDF Wrap before publishing it. Unit Testing PDF Wrap uses Mocha to run its tests. In addition, chaijs is used to assert test results. And for mocking classes, ts-mockito is used. Where to write tests All unit tests are declared in the test directory. This directory remains in the same structure like the src directory. Test files must end with .spec.ts and any files containing mock classes (if needed) must end with .mock.ts . The file name of a unit test is the same where the class or function you wanna test, is declared. For Example src/pdfjs/my-service.ts contains a function called doBar you wanna test. test/pdfjs/my-service.spec.ts must be the file name of the unit test. Test style Mocha is a BDD (Behaviour Driven Development) testing Framework. Therefore we organize our test like this. Testing classes The unit test structure of a class describe('the class you test', () => { describe('the method you test', () => { describe('the case of the method you test', () => { it('should do what you expect', () => { // AAA }); }); }); }); This way you have a group per class, per method and per case of a method. The it block should always start with \"should\". For example, if you expect an error to be thrown: it(\"should throw an error indicating that ...\", () => { ... }) AAA stands for Arrange , Act and Assert , which means a test should be structured in that way. Arrange everything for the test like mocks Act, which means that you invoke the method or function you wanna test Assert if everything worked like expected Pro Tip: Mark where your Arrange stops and your Act starts or where your Act stops and your Assert starts with two blank lines between them. Sometimes you just can not have this structure. Especially when you test for errors, because you have to invoke the tested method or function during the assert. AAA is more a guide line rather than an absolute rule. Testing functions When you test functions its pretty much the same structure, but you leave out the class describe. describe('the function you test', () => { describe('the case you test', () => { it('should do what you expect', () => { // AAA }); }); }); Mocha Mocha has a cli options file which will be used: test/mocha.opt . This file contains command line arguments which should be used when running mocha. Read more about Mocha Options ts-mockito ts-mockito is a mocking library for Typescript. A big advantages is, that you don't lose the type definitions like you would for example with Sinon.js Mocking interfaces Because interfaces are a Typescript only thing and are not available during the runtime, ts-mockito can not mock interfaces. So you have to create a mock class of the interface you wanna mock your-self. Because ts-mockito can mock classes, you only have to create a mock class as an empty implementation, rather than a mock class for each case you wanna test. Example mocking interface This is our interface export interface MyService { bar: number; readonly foo: number; doBar(): void; } You create a mock class for it export class MockMyService implements MyService { get bar(): number { throw new Error(\"Not implemented test stub\"); } set bar(_: number): void { throw new Error(\"Not implemented test stub\"); } get foo(): number { throw new Error(\"Not implemented test stub\"); } doBar(): void { throw new Error(\"Not implemented test stub\"); } } Please note, that all implementations, including the properties, do throw an Error indicating that this test stub is not implemented. This makes sure you do not have a side effect when you forgot to manipulate a method or property. In addition, parameters should be renamed to a _ symbol, otherwise the Typescript compiler would report an error. Read more about Unused Parameters Please note, that ts-mockito can mock an abstract class, but only manipulate non-abstract methods. Therefore, an interface can not be mocked by creating an abstract class of it and use the abstract class as the mock class. Miscellaneous CSS Whenever you have to declare CSS you must add it in the file src/assets/css/pdf-wrap.css . When the project is be built, this file will be concat together with the CSS file of PDF.js. Custom type def Whenever small type definitions are needed, they can be written in the src/declarations.ts file. But it should not contain too much type defs of the same library. If that's the case, create a directory in the src/declarations directory named after the library you wanna use and write your type definitions there. Unused Parameters Because our tsconfig.json enables the noUnusedParameter flag, you would get an error whenever you don't need a parameter. Instead of just not declare the parameter, you should rename it with a _ symbol. This way the Typescript compiler will not report an error and a developer does know, there is a parameter but it is not used. In case you have multiple parameters you don't need, just add a additional _ to the second unused parameter. Example // unused parameter doBar(_: number): void { ... } // two unused parameters doBar(_: nmuber, __: number): void { ... } // three unused parameters doBar(_: number, __: number, ___: number): void { ... } // two unused with one used parameter doBar(_: number, usedParameter: number, __: number): void { console.log(usedParameter); } // and so on This also can be applied to any case where a parameter is unused, whenever its a lambda expression, a method to implement or even a setter. Type Doc The type doc should be written in most cases. There are exceptions like getters / setters. In addition to the the description in a type doc, there should be the following type doc annotations: @author your-name <your-email> - e.g. @author Max Muster <mm@gmail.com> @since current-pdfwrap-version - e.g. @since 1.0.0 @internal - is optional and should be declared whenever something is only used intern of PDF Wrap PDF.js PDF Wrap makes a high usage of PDF.js , which is written in Javascript. The distribution of PDF.js is only the parsing functionality. But we also use their PDF Viewer. Because of that, some parts of the PDF.js node module will be copied to the build output. Type def Definitelytyped contains a type def for PDF.js, but unfortunately it is not correct. Therefore we have our own type def of PDF.js, located in src/declarations/pdfjs . This type def is not complete and contains only what we need right now. Whenever you need more of the API of PDF.js, you have to extend the type def.","title":"Development Guide"},{"location":"development-guide/#development-guide","text":"Authors Nicolas M\u00e4rchy Nicolas Sch\u00e4fli Version 1.0.0 Copyright \u00a9 2018 studer + raimann ag, Creative Commons Attribution-ShareAlike 4.0 International License .","title":"Development Guide"},{"location":"development-guide/#prerequisites","text":"Yarn - https://yarnpkg.com/lang/en Node.js - https://nodejs.org/en/ MkDocs - https://www.mkdocs.org/ ghp-import - https://github.com/davisp/ghp-import You need ghp-import on your PATH, otherwise you won't be able to publish the documentation.","title":"Prerequisites"},{"location":"development-guide/#architecture","text":"The API exposed to the user defines mainly interfaces a user can use. In contrast to the paint , which implements the possibility to draw, is only used internal of PDF Wrap. The pdfjs is the PDF.js implementation for the API.","title":"Architecture"},{"location":"development-guide/#displaying-pdf-pages","text":"The PDF pages are displayed by PDF.js. But the highlight as well as the drawing are displayed by PDF Wrap. Every page is displayed in a specific way. HIGHLIGHT LAYER This layer contains any text highlighting with a 100% opacity. It is beneath the actual rendered PDF page, so it won't cover the text. PDF LAYER Is the actual PDF page rendered as svg by PDF.js. HIGHLIGHT LAYER TRANSPARENCY This layer contains any highlighting with an opacity of (about 40%). DRAW LAYER The layer contains all drawings made by a user. TEXT LAYER Is the invisible actual text of the PDF page. Is rendered by PDF.js and enables the text selection, because on the PDF LAYER is no text selection available. Must be invisible, because its only purpose is the text selection. The text itself may not have the correct font or exact position on the page.","title":"Displaying PDF Pages"},{"location":"development-guide/#directory-structure","text":"1. /pdf-wrap - Root The PDF Wrap root directory Every single file and directory of PDF Wrap Directly in this directory are configuration files like package.json or tsconfg.json 2. /build - Build Output Contains all generated output files The /build directory has a specific structure itself. Read more about build directory 3. /docs - Documentation Source Contains the documentation's source files 4. /examples - PDF Wrap Examples Contains examples of how to use PDF Wrap Contains a Dev Viewer example mainly used for development 5. /src - Source Code Contains the source code of PDF Wrap This also contains type definition files of libraries which don't have type definitions them-self 6. /test - Unit Test Contains unit test files This also contains files with Mock object of for example interfaces Unit Test files must end with .spec.ts Mock files must end with .mock.ts Only files ending to .spec.ts or .mock.ts are picked up by Typescript","title":"Directory Structure"},{"location":"development-guide/#build-directory","text":"The build directory is the output directory for any file generated through the Tasks . It is structured in a specific way. 1. /javascript - Transpiled Code Directly transpiled typescript code from src and test directory No uglifying No dependencies 2. /libs - Production Ready This code is production ready Uglified With dependencies and additional resources like CSS files 3. /distributions - Distribution Ready This code is ready to be distributed Uglified With dependencies and additional resources like CSS files With README file With CHANGELOG file With modified package.json file 4. /docs - Built Documentation Generated documentation like MkDocs or Typedoc","title":"build directory"},{"location":"development-guide/#tasks","text":"PDF Wrap uses Gulp for its task management. The gulpfile.js uses the app.properties.js file to get specific directories. The app.properties.js file just exports an object, which resolves important directory paths absolute.","title":"Tasks"},{"location":"development-guide/#build-tasks","text":"The build tasks contain tasks all around building the project. clean Cleans the build by removing the build directory. build Transpiles and lints typescript and runs the tests. package Packs the project ready to use. Copies resources needed and uglifies the javascript code. repackage Same as package but executes clean before uglifyJS Uglifies the javascript code","title":"build Tasks"},{"location":"development-guide/#docs-tasks","text":"The docs tasks contain tasks about generating or publishing the documentation. mkdocs Generates the MkDocs documentation and includes the typedoc. typedoc Generates the typedoc api documentation. publishDoc Generates and publishes the MkDocs.","title":"docs Tasks"},{"location":"development-guide/#other-tasks","text":"The other tasks contain tasks which have more a general purpose, rather than something specific. copyDependencies Copies the projects dependencies. copyImages Copies the images used by PDF.js copyCMaps Copies the cMaps of PDF.js copyPDFJS Copies the PDF.js files needed. copyCSS Copies and concat the CSS files needed. transformPackageJSON Declares every dependency used in package.json as bundledDependencies . This is needed, because PDF Wrap does not come with a bundled js file. Therefore npm needs to know, that the dependencies are bundled. In addition, devDependecies are cleared, because they are not needed for production. transpileTypescript Transpiles typescript to javascript and generates inline source maps.","title":"other Tasks"},{"location":"development-guide/#npm-tasks","text":"The npm tasks contain tasks used for npmjs . pack Runs yarn pack for the build/distributions/npm directory. publish Publishes the project to npm.","title":"npm Tasks"},{"location":"development-guide/#verification-tasks","text":"The verification tasks contain tasks about testing. test Runts the unit tests. lint Lints the typescript code.","title":"verification Tasks"},{"location":"development-guide/#logging","text":"PDF Wrap uses typescript-logging . The configuration is abstracted to the user, to enable a unified log output.","title":"Logging"},{"location":"development-guide/#the-logger-name","text":"The logger name has a specific scheme in order to enable a unified and an exact as possible log output. <namespace>/<file-path>:<class-name> <namespace> The namespace is always the same value: ch/studerraimann/pdfwrap <file-path> The path of the file where you create the logger. The file name must be without the extension and the file path is relative to the src directory of PDF Wrap. <class-name> The class or function name where you create the logger.","title":"The logger name"},{"location":"development-guide/#example-class","text":"Assuming the class is declared in the file src/services/my-service.ts . export class MyService { private readonly log: Logger = LoggerFactory.getLogger(\"ch/studerraimann/pdfwrap/services/my-service:MyService\"); constructor() { this.log.info(() => \"Call constructor of MyService\"); }","title":"Example: Class"},{"location":"development-guide/#example-file","text":"Assuming the function is declared in the file src/services/my-service.ts . export function doSomething() { const log: Logger = LoggerFactory.getLogger(\"ch/studerraimann/pdfwrap/services/my-service:doSomething\"); log.info(() => \"Call doSomething\"); } You should always use the lambda expression for a log message, because this way it will only be executed when its needed. Please note, that the Logger type must be imported from typescript-logging , but the LoggerFactory class is from src/log-config.ts .","title":"Example: File"},{"location":"development-guide/#why-using-it-this-way","text":"PDF Wrap provides an API to configure the logging output way down to a function or class. This way, the logger names are unified and as a result the configuration can be applied to every logger. Read the Reference Documentation about logging to understand the concept better.","title":"Why using it this way?"},{"location":"development-guide/#mkdocs","text":"The PDF Wrap documentation is built with MkDocs . The documentation contains the following parts. Home The index of the documentation. Contains a quick start and link to other parts of the documentation. Guides Contains guides with a specific example of a specific part of PDF Wrap. For example: How to implement a Storage Adapter API Documentation The API documentation of PDF Wrap is part of the final output, but is not actually made by MkDocs. Reference Documentation Contains the full in-depth documentation about how to use PDF Wrap. Development Guide Contains guides about the source code and how to develop with PDF Wrap.","title":"MkDocs"},{"location":"development-guide/#how-to-publish-the-documentation","text":"In order to publish the documentation, you must have MkDocs installed and ghp-import must be on your PATH. Then simply run yarn gulp publishDoc This will generate the documentation, updates the gh-pages branch and pushes it to Github.","title":"How to publish the documentation"},{"location":"development-guide/#npm","text":"PDF Wrap is published to npm.js .","title":"NPM"},{"location":"development-guide/#how-to-publish-pdf-wrap","text":"In order to publish this project to npm you have to log in with your npm account yarn login Then simply run yarn gulp publish It is important to use this command and NOT yarn publish directly, because the gulp command will prepare PDF Wrap before publishing it.","title":"How to publish PDF Wrap"},{"location":"development-guide/#unit-testing","text":"PDF Wrap uses Mocha to run its tests. In addition, chaijs is used to assert test results. And for mocking classes, ts-mockito is used.","title":"Unit Testing"},{"location":"development-guide/#where-to-write-tests","text":"All unit tests are declared in the test directory. This directory remains in the same structure like the src directory. Test files must end with .spec.ts and any files containing mock classes (if needed) must end with .mock.ts . The file name of a unit test is the same where the class or function you wanna test, is declared. For Example src/pdfjs/my-service.ts contains a function called doBar you wanna test. test/pdfjs/my-service.spec.ts must be the file name of the unit test.","title":"Where to write tests"},{"location":"development-guide/#test-style","text":"Mocha is a BDD (Behaviour Driven Development) testing Framework. Therefore we organize our test like this.","title":"Test style"},{"location":"development-guide/#testing-classes","text":"The unit test structure of a class describe('the class you test', () => { describe('the method you test', () => { describe('the case of the method you test', () => { it('should do what you expect', () => { // AAA }); }); }); }); This way you have a group per class, per method and per case of a method. The it block should always start with \"should\". For example, if you expect an error to be thrown: it(\"should throw an error indicating that ...\", () => { ... }) AAA stands for Arrange , Act and Assert , which means a test should be structured in that way. Arrange everything for the test like mocks Act, which means that you invoke the method or function you wanna test Assert if everything worked like expected Pro Tip: Mark where your Arrange stops and your Act starts or where your Act stops and your Assert starts with two blank lines between them. Sometimes you just can not have this structure. Especially when you test for errors, because you have to invoke the tested method or function during the assert. AAA is more a guide line rather than an absolute rule.","title":"Testing classes"},{"location":"development-guide/#testing-functions","text":"When you test functions its pretty much the same structure, but you leave out the class describe. describe('the function you test', () => { describe('the case you test', () => { it('should do what you expect', () => { // AAA }); }); });","title":"Testing functions"},{"location":"development-guide/#mocha","text":"Mocha has a cli options file which will be used: test/mocha.opt . This file contains command line arguments which should be used when running mocha. Read more about Mocha Options","title":"Mocha"},{"location":"development-guide/#ts-mockito","text":"ts-mockito is a mocking library for Typescript. A big advantages is, that you don't lose the type definitions like you would for example with Sinon.js","title":"ts-mockito"},{"location":"development-guide/#mocking-interfaces","text":"Because interfaces are a Typescript only thing and are not available during the runtime, ts-mockito can not mock interfaces. So you have to create a mock class of the interface you wanna mock your-self. Because ts-mockito can mock classes, you only have to create a mock class as an empty implementation, rather than a mock class for each case you wanna test.","title":"Mocking interfaces"},{"location":"development-guide/#example-mocking-interface","text":"This is our interface export interface MyService { bar: number; readonly foo: number; doBar(): void; } You create a mock class for it export class MockMyService implements MyService { get bar(): number { throw new Error(\"Not implemented test stub\"); } set bar(_: number): void { throw new Error(\"Not implemented test stub\"); } get foo(): number { throw new Error(\"Not implemented test stub\"); } doBar(): void { throw new Error(\"Not implemented test stub\"); } } Please note, that all implementations, including the properties, do throw an Error indicating that this test stub is not implemented. This makes sure you do not have a side effect when you forgot to manipulate a method or property. In addition, parameters should be renamed to a _ symbol, otherwise the Typescript compiler would report an error. Read more about Unused Parameters Please note, that ts-mockito can mock an abstract class, but only manipulate non-abstract methods. Therefore, an interface can not be mocked by creating an abstract class of it and use the abstract class as the mock class.","title":"Example mocking interface"},{"location":"development-guide/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"development-guide/#css","text":"Whenever you have to declare CSS you must add it in the file src/assets/css/pdf-wrap.css . When the project is be built, this file will be concat together with the CSS file of PDF.js.","title":"CSS"},{"location":"development-guide/#custom-type-def","text":"Whenever small type definitions are needed, they can be written in the src/declarations.ts file. But it should not contain too much type defs of the same library. If that's the case, create a directory in the src/declarations directory named after the library you wanna use and write your type definitions there.","title":"Custom type def"},{"location":"development-guide/#unused-parameters","text":"Because our tsconfig.json enables the noUnusedParameter flag, you would get an error whenever you don't need a parameter. Instead of just not declare the parameter, you should rename it with a _ symbol. This way the Typescript compiler will not report an error and a developer does know, there is a parameter but it is not used. In case you have multiple parameters you don't need, just add a additional _ to the second unused parameter. Example // unused parameter doBar(_: number): void { ... } // two unused parameters doBar(_: nmuber, __: number): void { ... } // three unused parameters doBar(_: number, __: number, ___: number): void { ... } // two unused with one used parameter doBar(_: number, usedParameter: number, __: number): void { console.log(usedParameter); } // and so on This also can be applied to any case where a parameter is unused, whenever its a lambda expression, a method to implement or even a setter.","title":"Unused Parameters"},{"location":"development-guide/#type-doc","text":"The type doc should be written in most cases. There are exceptions like getters / setters. In addition to the the description in a type doc, there should be the following type doc annotations: @author your-name <your-email> - e.g. @author Max Muster <mm@gmail.com> @since current-pdfwrap-version - e.g. @since 1.0.0 @internal - is optional and should be declared whenever something is only used intern of PDF Wrap","title":"Type Doc"},{"location":"development-guide/#pdfjs","text":"PDF Wrap makes a high usage of PDF.js , which is written in Javascript. The distribution of PDF.js is only the parsing functionality. But we also use their PDF Viewer. Because of that, some parts of the PDF.js node module will be copied to the build output.","title":"PDF.js"},{"location":"development-guide/#type-def","text":"Definitelytyped contains a type def for PDF.js, but unfortunately it is not correct. Therefore we have our own type def of PDF.js, located in src/declarations/pdfjs . This type def is not complete and contains only what we need right now. Whenever you need more of the API of PDF.js, you have to extend the type def.","title":"Type def"},{"location":"reference-documentation/","text":"PDF Wrap Reference Documentation Authors Nicolas M\u00e4rchy Nicolas Sch\u00e4fli Version 1.0.0 Copyright \u00a9 2018 studer + raimann ag, Creative Commons Attribution-ShareAlike 4.0 International License . Getting Started As a note, PDF Wrap does not come with a bundled js file. If you want a bundled version, you have to bundle it yourself (e.g. with webpack ). Requirements Language level: ES5 Module System: commonjs FileReader support Blob support Easy way to check the FileReader and Blob support if (window.FileReader && window.Blob) { // Great success! All the required File APIs are supported. } else { alert('The required File APIs are not fully supported in this browser.'); } Installing PDF Wrap can be installed with npm or yarn. Yarn Install yarn add pdf-wrap NPM Install npm i pdf-wrap Using PDF Wrap This section goes into more detail about how you should use PDF Wrap. It covers topics such as using the api, toolbox and how to provide your storage adapter. Setup HTML In order to use PDF Wrap properly you have to setup a minimalistic html. Styles In order to display the PDF properly you should include the following css file. /assets/css/pdf-wrap.css HTML container You have to setup a html container in a specific way. <div class=\"pdf viewport\"> <div class=\"pdf-container\"> <div class=\"pdfViewer\"></div> </div> </div> Where the div with the class pdf viewport is your viewport. It is an absolute positioned div which will consume the entire area of its relative positioned parent. So either wrap it with another div which is aligned like you want it, or override the pdf viewport css styles. Anyway, make sure pdf viewport has a fix height, otherwise some features of PDF Wrap will not work. A fix height can also be a percentage based height like height: 100% . The viewport container should not be larger than the window, otherwise you'll get doubled scrollbars. Setup PDF.js Because PDF Wrap uses PDF.js under the hood, you have to provide the pdf.worker.js as well as some cMaps. The pdf.worker.js and the cMaps are delivered in the assets directory of PDF Wrap. Depending on how you build your project, either copy they to a directory of your choice or provide them somehow as resources. Either way you can set the assets src setAssetsSrc(\"resources/lib/pdf-wrap/assets\"); In this case, we assume, that the assets directory is copied into the resources/lib/pdf-wrap directory of the built project. Do NOT set the src url with starting ./ or ending / . The default value of the assets src is assets . Setup Logger PDF Wrap has a default log configuration which logs everything from log level Warn . You can override the default config LoggerFactory.configure({ logGroups: [ { logger: \"ch/studerraimann/pdfwrap\", logLevel: LogLevel.Trace } ] }); Each log group object accepts the property logger and logLevel . It allows you to define different log levels for different directories, files or even classes. logger defines which directory, file class or function should be used The string pattern scheme: ch/studerraimann/pdfwrap/<directory name>/<file name>:<class or function name> ch/studerraimann/pdfwrap - must be part of every logger /<directory name> - can be any directory structure inside the src directory of the PDF Wrap source code /<file name> - can be any file name (without extension) inside the specified directory name :<class or function name> - can be any class or function name inside the specified file name Example ch/studerrraimann/pdfwrap/pdfjs - for everything inside this directory ch/studerraimann/pdfwrap/pdfjs/highlight - for everything inside this file ch/studerraimann/pdfwrap/pdfjs/highlight:TextHighlighting - for the class TextHighlighting of the file highlight logLevel defines one of the log level to use on this group If you are using Typescript you can use the enumerator LogLevel . If you are using Javascript you have to use the string value which represents the log level of the enumerator: \"TRACE\" \"DEBUG\" \"INFO\" \"WARN\" \"ERROR\" \"FATAL\" Using the PDF Document Service The PDFDocumentService is your entry point to PDF Wrap. It provides a load method to load and display your PDF file. Create an instance of a PDFDocumentService const documentService: PDFDocumentService = new PDFjsDocumentService(); Note that PDFDocumentService is the interface and PDFjsDocumentService is an implementation of it. You must provide the PDF as a Blob documentService.loadWith({ container: document.getElementById(\"viewerContainer\"), pdf: pdfData, layerStorage: URI.from(\"file://my-pdf\") }).then(pdf => { // you'll get a PDFDocument instance }); Options: container: your div with the pdf-container class. pdf: a Blob representing your PDF file. layerStorage: an URI to use for the storage adapter Learn more about the StorageAdapter LayerStorage Example We assume the layerStorage is \"mem://my-pdf\" the registered storage adapter scheme is \"mem://\" // load the document documentService.loadWith({ container: document.getElementById(\"viewerContainer\"), pdf: \"assets/resources/my-pdf.pdf\", layerStorage: URI.from(\"mem://my-pdf\") }).then(pdf => { // you'll get a PDFDocument instance }); // the storage adapter will get the full URI export class MyStorageAdapter implements StorageAdapter { register(): URI { return URI.from(\"mem://\"); // we only provide the same scheme } start(uri: URI, events: PageEventCollection): void { // uri is mem://my-pdf } loadPage(uri: URI, pageNumber: number): Promise<PageOverlay> { // uri is mem://my-pdf } } It is important to know, that for the register method, only the URI scheme is considered. Where in the start and loadPage method, the full URI used by the loadWith method is provided. Otherwise, you would not be able to store different PDFs with the same Adapter. Using the toolbox Once you have loaded the PDF, you can access its toolbox. The toolbox contains the following tools: Freehand - to draw with the mouse on a PDF page Eraser - to remove drawings made with the Freehand tool pdf.toolbox.freehand; // get the freehand tool instance pdf.toolbox.eraser; // get the eraser tool instance All tools can be activated, deactivated or toggled pdf.toolbox.freehand.activate(); pdf.toolbox.freehand.deactivate(); pdf.toolbox.freehand.toggle(); All tools provide the current state through a property const isFreehandActive: boolean = pdf.toolbox.freehand.isActive; All tools provide an Observable which emits the new state in case of a state change pdf.toolbox.freehand.stateChange .subscribe(state => { if (state.isActive) { ... } else { ... } }) Freehand Limitations: The Freehand tool can not draw over multiple PDF pages at once The Freehand tool touchscreen support is experimental . The Freehand tool as additional setters: setColor - accepts a Color instance and defines the color of the stroke setStrokeWidth - accepts a number in px and defines the width of the stroke These setters can be chained pdf.toolbox.freehand .setColor(colorFromHex(\"#000\")) .setStrokeWidth(2); Learn more about colors: Using colors Eraser The Eraser can only remove strokes made with the Freehand tool. In order to remove a stroke, the eraser tool needs to be activated and the stroke needs to be crossed with the mouse while the mouse is pressed. Selection Limitations: The selected element can not be moved from one page to another. Multiselection is currently not supported. The selection can be used to select forms or drawings. An element selection supports the following operations: Resizing Repositioning Color change of the element (Fill & Border) Change of the drawing sequence (z axis) Forms The forms tool places form elements onto the document which may be transformed with the selection tool. Currently there are four types of forms supported: Rectangles Ellipse Circles Lines Forms can be placed with the forms tool located in the toolbox . pdf.toolbox.forms.circle.fillColor = colorFromHex(\"#F006\"); pdf.toolbox.forms.circle.borderColor = colorFromHex(\"#0F06\"); pdf.toolbox.forms.circle.create(); pdf.toolbox.forms.circle.create(); // Will have the same colors then the first circle. Using the highlighting Limitations: The highlight feature can not highlight text over multiple PDF pages at once. Once you have loaded the PDF, you can use its highlighting feature. The highlighting feature is disabled by default. You have to enable it if you want to provide it to your users. Enable highlighting pdf.highlighting.enable(); This will register several event listeners in order to enable the highlighting feature. To actually highlight a text selection you have to use the onTextSelection Observable. It'll will emit a TextSelection instance, whenever a text selection is performed by the user. In contrast to the onTextSelection , the onTextUnselection Observable emits whenever a text selection is cleared. pdf.highlighting.onTextSelection .subscribe(textSelection => { // use the textSelection here }); pdf.highlighting.onTextUnselection .subscribe(() => { // disable button }) This can be useful, if you want to enable or disable a button to highlight or to clear the text selection. The TextSelection instance provides a clearHighlight and a highlight method. clearHighlight will remove any highlight of the selected text highlight accepts a Color instance and highlights the selection with it Learn more about colors: Using colors PDF Wrap only adds or remove event listeners for the text selection. It does not actually disable the text select feature from a html page. If you want to disable it, you have to disable or enable it yourself through CSS . Provide your storage adapter In order to use PDF Wrap, you must provide a storage adapter. A storage adapter is used to store and load PDF annotations. export class MyStorageAdapter implements StorageAdapter { register(): URI { return URI.from(\"file://\"); } start(uri: URI, events: PageEventCollection): void { // listen on events } loadPage(uri: URI, pageNumber: number): Promise<PageOverlay> { // load page data } } You have to implement three methods: register , start and loadPage . register The schema of the returned URI determines if your storage provider is used or not. Which schema is used to load a PDF must be defined when the PDF is loaded. Read more about how to load a PDF: Using the PDF Document Service start Will be invoked when your storage provider is used. It'll provide the URI and a event collection, where you can listen to store the different annotations made on a PDF page. Each event is a hot Observable which emits specific objects. afterPolyLineRendered - Emits a DrawElement with the rendered PolyLine information. afterRectangleRendered - Emits a DrawElement with the rendered Rectangle information. afterElementRemoved - Emits a DrawElement with the Element information which was removed. A DrawEvent contains a layer and a pageNumber property which you should store as well, because you have to provide highlights and drawings separated in your loadPage method. The layer property is either PageLayer.HIGHLIGHT or PageLayer.DRAWING . loadPage You have to provide the page information to the given pageNumber . Highlights and drawings are separated. In order to build the different elements you should use the ElementBuilderFactory class. async loadPage(uri, URI, pageNumber: number): Promise<PageOverlay> { // load your page information return new PageOverlay( pageNumber, [...], // your highlights [...] // your drawings ) } Read more about how to build elements: Using the ElementBuilderFactory Add your storage adapter to the StorageRegistry In order to provide your storage adapter to PDF Wrap you have to add it to the StorageRegistry . The StorageRegistry is a singleton where you can add as many storage adapters as you want. StorageRegistry.instance .add(new MyStorageAdapter()) .add(new MyStorageadapter2()); Skippable Storage Adapter You can provide multiple storage adapters for the same URI schema. When the events from the start method are fired, every storage adapter will be used to store the data. But when the PDF is loaded only one storage adapter can be used. Usually the first storage adapter will be used. But you can make your storage adapter skippable. This can be useful, if you want to load the data, but in case it'll fail, delegate to the next storage adapter. To make your storage adapter skippable extend the abstract class SkippableStorageAdapter . export class MySkippableStorageAdapter extends SkippableStorgaeAdapter { ... // other methods loadPage(pageNumber: number): Promise<PageOverlay> { try { // load page data } catch (error) { this.skip(); } } } The skip method will abort the loading process of this adapter and continues with the next available adapter. Empty Storage Adapter If you don't want to provide a StorageAdapter you can register an EmptyStorageAdapter instance StorageRegistry.instance .add(new EmptyStorageAdapter(URI.from(\"ex://\"))); You should only provide the EmptyStorageAdapter if you are not using the toolbox or highlighting at all. Using the ElementBuilderFactory In order to create elements used in a StorageAdapter you should use the ElementBuilderFactory . const elementBuilder: ElementBuilderFactory = new ElementBuilderFactoryImpl(); const polyLine: PolyLine = elementBuilder.polyLine() .id(\"some-id\") .borderColor(colorFromHex(\"000000\")) .coordinates([{x: 47.51, y: 201.45}, {x: 48.8, y: 202.02}]) .build(); PDF Wrap Features Search PDF Wrap provides a full text search over a PDF document. To access the DocumentSearch you have to load a PDF. Once you have loaded the PDF, you can access the SearchDocument pdf.searchController; A DocumentSearch provides you with different methods: search - to start a search against a term previous - to select the previous search result found by search next - to select the next search result found by search The search methods accepts two parameters, query and options where query is self explained and options are different flags for the search. searchPhrase - if true the search term will be used as a phrase, otherwise as a term fuzzy - if true the search operation is performed case insensitive, otherwise case sensitive highlightAll - if true highlights all search results, otherwise only the active selected Example Search pdf.searchController.search(\"example\", { highlightAll: true, searchPhrase: false, fuzzy: true}); Outline You can access the outline of a PDF once the PDF is loaded pdf.getOutline().then(outline => { // use the outline }) The Outline class provides two different forms of the outline. The flatList and the tree structure, where the flatList means, that even nested outlines are at the top level. The tree structure remains in the nested structure of the PDF outline. Each outline provides the title as well as the pageNumber // use with flat list pdf.getOutline().then(outline => { outline.flatList.forEach(item => { item.title; item.pageNumber; }); }); // use tree with children pdf.getOutline().then(outline => { outline.tree.forEach(item => { item.title; item.pageNumber; item.children; // nested outlines }); }); You want to jump to the page where the outline points to? Check out Page Navigation Page Thumbnails You can access thumbnails of the PDF pages once the PDF is loaded // get the thumbnail of page 1, 2 and 3 with a max size of 96px pdf.getThumbnails(96, 1, 2, 3).subscribe(thumbnail => { // use the thumbnail }); The getThumbails method returns an Observable which emits every thumbnail after another. Once the last thumbnail is loaded, the Observable completes. The first parameter maxSize defines the max size, a thumbnail can be. The second parameter pageNumbers is a vararg for the page number you want the thumbnail of. Tip: If you want to get the thumbnail of all pages, use a while loop to get all page numbers of the document const pages: Array<number> = []; while (pages.length < pdf.pageCount) pages.push(pages.length + 1); Page Navigation You can switch to a page by simply setting the currentPageNumber property of the PDFDocument pdf.currentPageNumber = 5; // next page pdf.currentPageNumber = pdf.currentPageNumber + 1; // previous page pdf.currentPageNumber = pdf.currentPageNumber - 1; Zoom You can zoom in or zoom out by simply setting the scale property of the PDFDocument pdf.scale = pdf.scale * 1.5; // will zoom in by 150% pdf.scale = pdf.scale / 1.5; // will zoom out by 150% // or set a fix zoom value pdf.scale = 1.5; // will zoom to 150% Miscellaneous Using colors Whenever a color can be set in PDF Wrap, a Color instance is required. To create a Color instances use one of the following functions. Module: api/draw/color colorFrom colorFromHex colorFromRgba There are predefined colors with the Colors enumerator available. If you're looking for valid values of these functions, please consider the typedoc API .","title":"Reference Documentation"},{"location":"reference-documentation/#pdf-wrap-reference-documentation","text":"Authors Nicolas M\u00e4rchy Nicolas Sch\u00e4fli Version 1.0.0 Copyright \u00a9 2018 studer + raimann ag, Creative Commons Attribution-ShareAlike 4.0 International License .","title":"PDF Wrap Reference Documentation"},{"location":"reference-documentation/#getting-started","text":"As a note, PDF Wrap does not come with a bundled js file. If you want a bundled version, you have to bundle it yourself (e.g. with webpack ).","title":"Getting Started"},{"location":"reference-documentation/#requirements","text":"Language level: ES5 Module System: commonjs FileReader support Blob support Easy way to check the FileReader and Blob support if (window.FileReader && window.Blob) { // Great success! All the required File APIs are supported. } else { alert('The required File APIs are not fully supported in this browser.'); }","title":"Requirements"},{"location":"reference-documentation/#installing","text":"PDF Wrap can be installed with npm or yarn.","title":"Installing"},{"location":"reference-documentation/#yarn-install","text":"yarn add pdf-wrap","title":"Yarn Install"},{"location":"reference-documentation/#npm-install","text":"npm i pdf-wrap","title":"NPM Install"},{"location":"reference-documentation/#using-pdf-wrap","text":"This section goes into more detail about how you should use PDF Wrap. It covers topics such as using the api, toolbox and how to provide your storage adapter.","title":"Using PDF Wrap"},{"location":"reference-documentation/#setup-html","text":"In order to use PDF Wrap properly you have to setup a minimalistic html.","title":"Setup HTML"},{"location":"reference-documentation/#styles","text":"In order to display the PDF properly you should include the following css file. /assets/css/pdf-wrap.css","title":"Styles"},{"location":"reference-documentation/#html-container","text":"You have to setup a html container in a specific way. <div class=\"pdf viewport\"> <div class=\"pdf-container\"> <div class=\"pdfViewer\"></div> </div> </div> Where the div with the class pdf viewport is your viewport. It is an absolute positioned div which will consume the entire area of its relative positioned parent. So either wrap it with another div which is aligned like you want it, or override the pdf viewport css styles. Anyway, make sure pdf viewport has a fix height, otherwise some features of PDF Wrap will not work. A fix height can also be a percentage based height like height: 100% . The viewport container should not be larger than the window, otherwise you'll get doubled scrollbars.","title":"HTML container"},{"location":"reference-documentation/#setup-pdfjs","text":"Because PDF Wrap uses PDF.js under the hood, you have to provide the pdf.worker.js as well as some cMaps. The pdf.worker.js and the cMaps are delivered in the assets directory of PDF Wrap. Depending on how you build your project, either copy they to a directory of your choice or provide them somehow as resources. Either way you can set the assets src setAssetsSrc(\"resources/lib/pdf-wrap/assets\"); In this case, we assume, that the assets directory is copied into the resources/lib/pdf-wrap directory of the built project. Do NOT set the src url with starting ./ or ending / . The default value of the assets src is assets .","title":"Setup PDF.js"},{"location":"reference-documentation/#setup-logger","text":"PDF Wrap has a default log configuration which logs everything from log level Warn . You can override the default config LoggerFactory.configure({ logGroups: [ { logger: \"ch/studerraimann/pdfwrap\", logLevel: LogLevel.Trace } ] }); Each log group object accepts the property logger and logLevel . It allows you to define different log levels for different directories, files or even classes. logger defines which directory, file class or function should be used The string pattern scheme: ch/studerraimann/pdfwrap/<directory name>/<file name>:<class or function name> ch/studerraimann/pdfwrap - must be part of every logger /<directory name> - can be any directory structure inside the src directory of the PDF Wrap source code /<file name> - can be any file name (without extension) inside the specified directory name :<class or function name> - can be any class or function name inside the specified file name Example ch/studerrraimann/pdfwrap/pdfjs - for everything inside this directory ch/studerraimann/pdfwrap/pdfjs/highlight - for everything inside this file ch/studerraimann/pdfwrap/pdfjs/highlight:TextHighlighting - for the class TextHighlighting of the file highlight logLevel defines one of the log level to use on this group If you are using Typescript you can use the enumerator LogLevel . If you are using Javascript you have to use the string value which represents the log level of the enumerator: \"TRACE\" \"DEBUG\" \"INFO\" \"WARN\" \"ERROR\" \"FATAL\"","title":"Setup Logger"},{"location":"reference-documentation/#using-the-pdf-document-service","text":"The PDFDocumentService is your entry point to PDF Wrap. It provides a load method to load and display your PDF file. Create an instance of a PDFDocumentService const documentService: PDFDocumentService = new PDFjsDocumentService(); Note that PDFDocumentService is the interface and PDFjsDocumentService is an implementation of it. You must provide the PDF as a Blob documentService.loadWith({ container: document.getElementById(\"viewerContainer\"), pdf: pdfData, layerStorage: URI.from(\"file://my-pdf\") }).then(pdf => { // you'll get a PDFDocument instance }); Options: container: your div with the pdf-container class. pdf: a Blob representing your PDF file. layerStorage: an URI to use for the storage adapter Learn more about the StorageAdapter","title":"Using the PDF Document Service"},{"location":"reference-documentation/#layerstorage-example","text":"We assume the layerStorage is \"mem://my-pdf\" the registered storage adapter scheme is \"mem://\" // load the document documentService.loadWith({ container: document.getElementById(\"viewerContainer\"), pdf: \"assets/resources/my-pdf.pdf\", layerStorage: URI.from(\"mem://my-pdf\") }).then(pdf => { // you'll get a PDFDocument instance }); // the storage adapter will get the full URI export class MyStorageAdapter implements StorageAdapter { register(): URI { return URI.from(\"mem://\"); // we only provide the same scheme } start(uri: URI, events: PageEventCollection): void { // uri is mem://my-pdf } loadPage(uri: URI, pageNumber: number): Promise<PageOverlay> { // uri is mem://my-pdf } } It is important to know, that for the register method, only the URI scheme is considered. Where in the start and loadPage method, the full URI used by the loadWith method is provided. Otherwise, you would not be able to store different PDFs with the same Adapter.","title":"LayerStorage Example"},{"location":"reference-documentation/#using-the-toolbox","text":"Once you have loaded the PDF, you can access its toolbox. The toolbox contains the following tools: Freehand - to draw with the mouse on a PDF page Eraser - to remove drawings made with the Freehand tool pdf.toolbox.freehand; // get the freehand tool instance pdf.toolbox.eraser; // get the eraser tool instance All tools can be activated, deactivated or toggled pdf.toolbox.freehand.activate(); pdf.toolbox.freehand.deactivate(); pdf.toolbox.freehand.toggle(); All tools provide the current state through a property const isFreehandActive: boolean = pdf.toolbox.freehand.isActive; All tools provide an Observable which emits the new state in case of a state change pdf.toolbox.freehand.stateChange .subscribe(state => { if (state.isActive) { ... } else { ... } })","title":"Using the toolbox"},{"location":"reference-documentation/#freehand","text":"Limitations: The Freehand tool can not draw over multiple PDF pages at once The Freehand tool touchscreen support is experimental . The Freehand tool as additional setters: setColor - accepts a Color instance and defines the color of the stroke setStrokeWidth - accepts a number in px and defines the width of the stroke These setters can be chained pdf.toolbox.freehand .setColor(colorFromHex(\"#000\")) .setStrokeWidth(2); Learn more about colors: Using colors","title":"Freehand"},{"location":"reference-documentation/#eraser","text":"The Eraser can only remove strokes made with the Freehand tool. In order to remove a stroke, the eraser tool needs to be activated and the stroke needs to be crossed with the mouse while the mouse is pressed.","title":"Eraser"},{"location":"reference-documentation/#selection","text":"Limitations: The selected element can not be moved from one page to another. Multiselection is currently not supported. The selection can be used to select forms or drawings. An element selection supports the following operations: Resizing Repositioning Color change of the element (Fill & Border) Change of the drawing sequence (z axis)","title":"Selection"},{"location":"reference-documentation/#forms","text":"The forms tool places form elements onto the document which may be transformed with the selection tool. Currently there are four types of forms supported: Rectangles Ellipse Circles Lines Forms can be placed with the forms tool located in the toolbox . pdf.toolbox.forms.circle.fillColor = colorFromHex(\"#F006\"); pdf.toolbox.forms.circle.borderColor = colorFromHex(\"#0F06\"); pdf.toolbox.forms.circle.create(); pdf.toolbox.forms.circle.create(); // Will have the same colors then the first circle.","title":"Forms"},{"location":"reference-documentation/#using-the-highlighting","text":"Limitations: The highlight feature can not highlight text over multiple PDF pages at once. Once you have loaded the PDF, you can use its highlighting feature. The highlighting feature is disabled by default. You have to enable it if you want to provide it to your users. Enable highlighting pdf.highlighting.enable(); This will register several event listeners in order to enable the highlighting feature. To actually highlight a text selection you have to use the onTextSelection Observable. It'll will emit a TextSelection instance, whenever a text selection is performed by the user. In contrast to the onTextSelection , the onTextUnselection Observable emits whenever a text selection is cleared. pdf.highlighting.onTextSelection .subscribe(textSelection => { // use the textSelection here }); pdf.highlighting.onTextUnselection .subscribe(() => { // disable button }) This can be useful, if you want to enable or disable a button to highlight or to clear the text selection. The TextSelection instance provides a clearHighlight and a highlight method. clearHighlight will remove any highlight of the selected text highlight accepts a Color instance and highlights the selection with it Learn more about colors: Using colors PDF Wrap only adds or remove event listeners for the text selection. It does not actually disable the text select feature from a html page. If you want to disable it, you have to disable or enable it yourself through CSS .","title":"Using the highlighting"},{"location":"reference-documentation/#provide-your-storage-adapter","text":"In order to use PDF Wrap, you must provide a storage adapter. A storage adapter is used to store and load PDF annotations. export class MyStorageAdapter implements StorageAdapter { register(): URI { return URI.from(\"file://\"); } start(uri: URI, events: PageEventCollection): void { // listen on events } loadPage(uri: URI, pageNumber: number): Promise<PageOverlay> { // load page data } } You have to implement three methods: register , start and loadPage . register The schema of the returned URI determines if your storage provider is used or not. Which schema is used to load a PDF must be defined when the PDF is loaded. Read more about how to load a PDF: Using the PDF Document Service start Will be invoked when your storage provider is used. It'll provide the URI and a event collection, where you can listen to store the different annotations made on a PDF page. Each event is a hot Observable which emits specific objects. afterPolyLineRendered - Emits a DrawElement with the rendered PolyLine information. afterRectangleRendered - Emits a DrawElement with the rendered Rectangle information. afterElementRemoved - Emits a DrawElement with the Element information which was removed. A DrawEvent contains a layer and a pageNumber property which you should store as well, because you have to provide highlights and drawings separated in your loadPage method. The layer property is either PageLayer.HIGHLIGHT or PageLayer.DRAWING . loadPage You have to provide the page information to the given pageNumber . Highlights and drawings are separated. In order to build the different elements you should use the ElementBuilderFactory class. async loadPage(uri, URI, pageNumber: number): Promise<PageOverlay> { // load your page information return new PageOverlay( pageNumber, [...], // your highlights [...] // your drawings ) } Read more about how to build elements: Using the ElementBuilderFactory","title":"Provide your storage adapter"},{"location":"reference-documentation/#add-your-storage-adapter-to-the-storageregistry","text":"In order to provide your storage adapter to PDF Wrap you have to add it to the StorageRegistry . The StorageRegistry is a singleton where you can add as many storage adapters as you want. StorageRegistry.instance .add(new MyStorageAdapter()) .add(new MyStorageadapter2());","title":"Add your storage adapter to the StorageRegistry"},{"location":"reference-documentation/#skippable-storage-adapter","text":"You can provide multiple storage adapters for the same URI schema. When the events from the start method are fired, every storage adapter will be used to store the data. But when the PDF is loaded only one storage adapter can be used. Usually the first storage adapter will be used. But you can make your storage adapter skippable. This can be useful, if you want to load the data, but in case it'll fail, delegate to the next storage adapter. To make your storage adapter skippable extend the abstract class SkippableStorageAdapter . export class MySkippableStorageAdapter extends SkippableStorgaeAdapter { ... // other methods loadPage(pageNumber: number): Promise<PageOverlay> { try { // load page data } catch (error) { this.skip(); } } } The skip method will abort the loading process of this adapter and continues with the next available adapter.","title":"Skippable Storage Adapter"},{"location":"reference-documentation/#empty-storage-adapter","text":"If you don't want to provide a StorageAdapter you can register an EmptyStorageAdapter instance StorageRegistry.instance .add(new EmptyStorageAdapter(URI.from(\"ex://\"))); You should only provide the EmptyStorageAdapter if you are not using the toolbox or highlighting at all.","title":"Empty Storage Adapter"},{"location":"reference-documentation/#using-the-elementbuilderfactory","text":"In order to create elements used in a StorageAdapter you should use the ElementBuilderFactory . const elementBuilder: ElementBuilderFactory = new ElementBuilderFactoryImpl(); const polyLine: PolyLine = elementBuilder.polyLine() .id(\"some-id\") .borderColor(colorFromHex(\"000000\")) .coordinates([{x: 47.51, y: 201.45}, {x: 48.8, y: 202.02}]) .build();","title":"Using the ElementBuilderFactory"},{"location":"reference-documentation/#pdf-wrap-features","text":"","title":"PDF Wrap Features"},{"location":"reference-documentation/#search","text":"PDF Wrap provides a full text search over a PDF document. To access the DocumentSearch you have to load a PDF. Once you have loaded the PDF, you can access the SearchDocument pdf.searchController; A DocumentSearch provides you with different methods: search - to start a search against a term previous - to select the previous search result found by search next - to select the next search result found by search The search methods accepts two parameters, query and options where query is self explained and options are different flags for the search. searchPhrase - if true the search term will be used as a phrase, otherwise as a term fuzzy - if true the search operation is performed case insensitive, otherwise case sensitive highlightAll - if true highlights all search results, otherwise only the active selected","title":"Search"},{"location":"reference-documentation/#example-search","text":"pdf.searchController.search(\"example\", { highlightAll: true, searchPhrase: false, fuzzy: true});","title":"Example Search"},{"location":"reference-documentation/#outline","text":"You can access the outline of a PDF once the PDF is loaded pdf.getOutline().then(outline => { // use the outline }) The Outline class provides two different forms of the outline. The flatList and the tree structure, where the flatList means, that even nested outlines are at the top level. The tree structure remains in the nested structure of the PDF outline. Each outline provides the title as well as the pageNumber // use with flat list pdf.getOutline().then(outline => { outline.flatList.forEach(item => { item.title; item.pageNumber; }); }); // use tree with children pdf.getOutline().then(outline => { outline.tree.forEach(item => { item.title; item.pageNumber; item.children; // nested outlines }); }); You want to jump to the page where the outline points to? Check out Page Navigation","title":"Outline"},{"location":"reference-documentation/#page-thumbnails","text":"You can access thumbnails of the PDF pages once the PDF is loaded // get the thumbnail of page 1, 2 and 3 with a max size of 96px pdf.getThumbnails(96, 1, 2, 3).subscribe(thumbnail => { // use the thumbnail }); The getThumbails method returns an Observable which emits every thumbnail after another. Once the last thumbnail is loaded, the Observable completes. The first parameter maxSize defines the max size, a thumbnail can be. The second parameter pageNumbers is a vararg for the page number you want the thumbnail of. Tip: If you want to get the thumbnail of all pages, use a while loop to get all page numbers of the document const pages: Array<number> = []; while (pages.length < pdf.pageCount) pages.push(pages.length + 1);","title":"Page Thumbnails"},{"location":"reference-documentation/#page-navigation","text":"You can switch to a page by simply setting the currentPageNumber property of the PDFDocument pdf.currentPageNumber = 5; // next page pdf.currentPageNumber = pdf.currentPageNumber + 1; // previous page pdf.currentPageNumber = pdf.currentPageNumber - 1;","title":"Page Navigation"},{"location":"reference-documentation/#zoom","text":"You can zoom in or zoom out by simply setting the scale property of the PDFDocument pdf.scale = pdf.scale * 1.5; // will zoom in by 150% pdf.scale = pdf.scale / 1.5; // will zoom out by 150% // or set a fix zoom value pdf.scale = 1.5; // will zoom to 150%","title":"Zoom"},{"location":"reference-documentation/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"reference-documentation/#using-colors","text":"Whenever a color can be set in PDF Wrap, a Color instance is required. To create a Color instances use one of the following functions. Module: api/draw/color colorFrom colorFromHex colorFromRgba There are predefined colors with the Colors enumerator available. If you're looking for valid values of these functions, please consider the typedoc API .","title":"Using colors"},{"location":"guides/basic-viewer/","text":"Basic PDF viewer","title":"Basic PDF viewer"},{"location":"guides/basic-viewer/#basic-pdf-viewer","text":"","title":"Basic PDF viewer"}]}